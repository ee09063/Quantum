class Board
types
-- TODO Define types here
values
-- TODO Define values here
instance variables
	public pieces : set of Piece := { };
	public turn : seq1 of char := "White";
operations
	public Board : (set of Piece) ==> Board
	Board(initialPieces) == (
		pieces := initialPieces;
		return self;
	);
	
	public move: nat * nat * nat * nat ==> bool
		move(xi, yi, xf, yf) == 
		(
			dcl b : bool := getPiece(xi,yi).#2;
			dcl p : Piece := getPiece(xi,yi).#1;
			
			if not b then return false; 
			
			if not checkForPiece(xf,yf) then return movePiece(p,xf,yf);
			return capturePiece(p,xf,yf);
		);
	
	public movePiece: Piece * nat * nat ==> bool
		movePiece(p, xf, yf) == 
		(
			if p.getHeight() >= 6 then return false
			elseif p.getType() = "Square" then return moveSquarePiece(p, xf, yf)
			elseif p.getType() = "Circle" then return moveCirclePiece(p, xf, yf)
			elseif p.getType() = "Cross" then return moveCrossPiece(p, xf, yf);
			return false;
		);
	
	public capturePiece : Piece * nat * nat ==> bool
		capturePiece(p, xf, yf) == 
		(
			dcl target : Piece := getPiece(xf,yf).#1;
			
			if p.getHeight() >= 6 then return false
			elseif target.getColor() = p.getColor() then return false -- same color
			elseif p.getType() = "Square" then return captureSquarePiece(p, target)
			elseif p.getType() = "Circle" then return moveCirclePiece(p, xf, yf)
			elseif p.getType() = "Cross" then return moveCrossPiece(p, xf, yf);
			return false;
		);
	
	public moveSquarePiece : Piece * nat * nat ==> bool
		moveSquarePiece(p,xf,yf) == 
		(
			return ortogonalMovement(p,xf,yf);
		);
		
	public moveCirclePiece : Piece * nat * nat ==> bool
		moveCirclePiece(p,xf,yf) == 
		(
			return diagonalMovement(p,xf,yf);
		);
		
	public moveCrossPiece : Piece * nat * nat ==> bool
		moveCrossPiece(p,xf,yf) == 
		(
			if not ortogonalMovement(p, xf, yf) and not diagonalMovement(p,xf,yf) then return false;
			return true;
		);
	
	public captureSquarePiece : Piece * Piece ==> bool
		captureSquarePiece(p,t) == 
		(
			dcl xf : nat := t.getX();
			dcl yf : nat := t.getY();
			
			if not ortogonalMovement(p,xf,yf) then return false;
			p.addHeight();
			remove(t);
			return true;
			
		);
	
	public ortogonalMovement : Piece * nat * nat ==> bool
		ortogonalMovement(p,xf,yf) == 
		(
			dcl dx : nat := abs(p.getX()-xf);
			dcl dy : nat := abs(p.getY()-yf);
			
			if dx = 0 or dy = 0 then
			(
				if dx = 0 then
				(
					if dy <= p.getHeight() then
					(
						p.setX(xf);
						p.setY(yf);
						return true;
					)
				)
				elseif dy = 0 then
				(
					if dx <= p.getHeight() then
					(
						p.setX(xf);
						p.setY(yf);
						return true;
					)
				)
			);
			return false;
		);
		
	public diagonalMovement : Piece * nat * nat ==> bool
		diagonalMovement(p, xf, yf) == 
		(
			dcl dx : nat := abs(p.getX()-xf);
			dcl dy : nat := abs(p.getY()-yf);
			
			if dx = dy then
			(
				if dx <= p.getHeight() then
				(
					p.setX(xf);
					p.setY(yf);
					return true;
				)
			);
			return false;
		);
		
		public checkForPiece : nat * nat ==> bool
		checkForPiece(x,y) == 
		(
			for all p in set pieces do
				if p.getX() = x and p.getY() = y then return true;
			return false;
		);
		
		public getPiece : nat * nat ==> Piece * bool
			getPiece(x,y) == 
			(
				dcl pr : Piece := new Piece("White", "Square", 0, 0);
				for all p in set pieces do
					if p.getX() = x and p.getY() = y then return mk_(p,true);
				return mk_(pr, false);
			);
			
		public changeTurn : () ==> ()
			changeTurn() == 
			(
				if turn = "White" then turn := "Black"
				else turn := "White";
			);
			
		public remove : Piece ==> ()
			remove (z) ==
			(
				dcl nk : set of Piece := { };
				for all p in set pieces do
					if p <> z then nk := nk union {p};
				pieces := nk;
			);
		
		
end Board